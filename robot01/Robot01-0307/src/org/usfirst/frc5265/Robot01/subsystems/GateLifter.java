

// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5265.Robot01.subsystems;

import org.usfirst.frc5265.Robot01.RobotMap;
import org.usfirst.frc5265.Robot01.commands.*;

import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class GateLifter extends PIDSubsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController gateLifterVictor = RobotMap.gateLifterGateLifterVictor;
    private final AnalogPotentiometer potDisplay = RobotMap.gateLifterPotDisplay;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public static int fingerButton = 0;
    double upperPotLimitFinger = .8;
	double lowerPotLimitFinger = .3;
	
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
	public GateLifter() {
		super("GateLifter", 2.0, 0.0, 0.0);
			// The constructor passes a name for the subsystem and the P, I and D constants
			// that are used when computing the motor output
		setAbsoluteTolerance(0.05);
		getPIDController().setContinuous(false);
		LiveWindow.addActuator("Finger Subsystem1", "Gate Lifter Controller", getPIDController());
	}
	
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    	SmartDashboard.putNumber("upperPotLimitFinger", upperPotLimitFinger);
    	SmartDashboard.putNumber("lowerPotLimitFinger", lowerPotLimitFinger);
    	
        //SmartDashboard.getNumber("Upper Pot", 0.6);
    	
    }
    // this should show us the pot value on the dashboard
    protected double returnPIDInput(){
    	double value = potDisplay.pidGet();
    	SmartDashboard.putNumber("current pot value", value);
    	return value;    	
    }
    
    protected void usePIDOutput(double output) {
     	gateLifterVictor.pidWrite(output); 
     	// this is where the computed output value from the PIDController is applied to the motor
    }
    
    // our three test commands that the button and motor work    
    public void up(){
    	gateLifterVictor.set(1);
    }
    public void stop(){
    	gateLifterVictor.set(0);
    }  
    public void down(){
    	gateLifterVictor.set(-1);
    }
    
    // -1,0,1,2 are values for fingerButtonToggle, cycling through all four values
    // 0 and 2 are OFF, -1 is down, 1 is up
    // gatelifter.java will stop the up and down motion by the pot value
    // calling this function sets the toggle to the next integer
    // and returns that value    
    public static int fingerButtonToggle(){
 	   if (fingerButton == 1){
 		   fingerButton = 2;
 		   } else if (fingerButton == 2){
 			   fingerButton = -1; 
 		   } else if (fingerButton== -1){
 			   fingerButton = 0;
 		   } else if (fingerButton == 0){
 			   fingerButton = 1;
 		   }
 		   return fingerButton;
     }
    
}

/*
 * rewriting from the top
import edu.wpi.first.wpilibj.command.PIDSubsystem;
 
public class GateLifter extends PIDSubsystem {
	Victor gateLifterVictor = RobotMap.gateLifterGateLifterVictor;
	AnalogInput pot = RobotMap.gateLifterPotDisplay();

	// here are our starting variables
	public static int fingerButton = 0;
    double upperPotLimitFinger = .8;
	double lowerPotLimitFinger = .3;
	
	public Finger() {
		super("Finger", 2.0, 0.0, 0.0);
			// The constructor passes a name for the subsystem and the P, I and D constants
			// that are used when computing the motor output
		setAbsoluteTolerance(0.05);
		getPIDController().setContinuous(false);
	}
	
    public void initDefaultCommand() {
    	// put the values on the dashboard so we can retrieve them later
    	SmartDashboard.putNumber("upperPotLimitFinger", upperPotLimitFinger);
    	SmartDashboard.putNumber("lowerPotLimitFinger", lowerPotLimitFinger);
    }

    protected double returnPIDInput() {
    	double value = potDisplay.pidGet();
    	SmartDashboard.putNumber("current pot value", value);
    	return value; 
    	// returns the sensor value that is providing the feedback for the system
    }

    protected void usePIDOutput(double output) {
     	motor.pidWrite(output); 
     	// this is where the computed output value from the PIDController is applied to the motor
    }
    
    // The rest of our commands go below here
}
*/
